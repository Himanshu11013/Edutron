from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json
from .utils import generate_notes
import os
from django.views.decorators.http import require_GET
import requests
from .models import Note
from django.views.decorators.http import require_http_methods

@csrf_exempt
def search_youtube_videos(request):
    """Search for educational YouTube videos based on query param 'q' or 'query'"""
    if request.method != "POST":
        return JsonResponse({"error": "Only POST method allowed."}, status=405)
    
    try:
        data = json.loads(request.body.decode("utf-8"))
        query = data.get("q") or data.get("query") or ""
        query = query.strip() if isinstance(query, str) else ""
        if not query:
            return JsonResponse({"error": "Search query is required."}, status=400)

        # Enhance search to be educational
        safe_query = f"{query} educational"

        api_key = os.getenv("YOUTUBE_API_KEY")
        if not api_key:
            return JsonResponse({"error": "YouTube API key not configured in environment."}, status=500)

        base_url = "https://www.googleapis.com/youtube/v3/search"
        params = {
            "part": "snippet",
            "maxResults": 15,
            "q": safe_query,
            "type": "video",
            "videoEmbeddable": "true",
            "key": api_key,
        }

        response = requests.get(base_url, params=params)
        if response.status_code != 200:
            try:
                error_msg = response.json().get('error', {}).get('message', 'Unknown error')
            except Exception:
                error_msg = 'Unknown error while parsing YouTube API response.'
            return JsonResponse({"error": f"YouTube API error: {error_msg}"}, status=500)

        data = response.json()
        
        # Debug: Print the response structure
        print(f"YouTube API Response: {data}")
        
        # Safely extract video data with error handling
        videos = []
        for item in data.get("items", []):
            try:
                # Check if required fields exist
                if not item.get("id") or not item.get("snippet"):
                    print(f"Skipping item with missing id or snippet: {item}")
                    continue
                    
                if item["id"].get("kind") != "youtube#video":
                    print(f"Skipping non-video item: {item['id']}")
                    continue
                
                video_data = {
                    "title": item["snippet"].get("title", "No Title"),
                    "videoId": item["id"].get("videoId"),
                    "thumbnail": item["snippet"].get("thumbnails", {}).get("high", {}).get("url", ""),
                    "channelTitle": item["snippet"].get("channelTitle", "Unknown Channel"),
                    "publishedAt": item["snippet"].get("publishedAt", ""),
                }
                
                # Only add if we have a valid videoId
                if video_data["videoId"]:
                    videos.append(video_data)
                else:
                    print(f"Skipping item with missing videoId: {item}")
                    
            except Exception as item_error:
                print(f"Error processing item {item}: {item_error}")
                continue
        
        print(f"Successfully processed {len(videos)} videos")

        return JsonResponse({"videos": videos, "message": "Videos fetched successfully."}, status=200)

    except Exception as e:
        print(f"Error in search_youtube_videos: {str(e)}")
        print(f"Error type: {type(e)}")
        import traceback
        print(f"Traceback: {traceback.format_exc()}")
        return JsonResponse({"error": f"Unexpected error: {str(e)}"}, status=500)

@csrf_exempt
def create_notes(request):
    """Create notes generated by AI and save to DB"""
    if request.method != "POST":
        return JsonResponse({"error": "Only POST method is supported"}, status=405)

    try:
        request_body = request.body.decode('utf-8')
        print(f"Raw request body: {request_body[:200]}")  # Debug first 200 chars

        if not request_body.strip():
            return JsonResponse({"error": "Empty request body"}, status=400)

        # Parse JSON data
        try:
            data = json.loads(request_body)
        except json.JSONDecodeError as e:
            print(f"JSON parsing error: {e}")
            return JsonResponse({"error": f"Invalid JSON in request: {str(e)}"}, status=400)

        print(f"Parsed request data: {data}")

        # Accept both userId and user_id for backward compatibility
        topic = data.get("topic")
        userId = data.get("userId") or data.get("user_id")

        # Validate required fields
        if not topic or not userId:
            return JsonResponse({"error": "Topic and userId are required"}, status=400)

        # Generate notes
        notes = generate_notes(topic)

        # Validate notes
        if not notes or len(notes.strip()) == 0:
            return JsonResponse({"error": "Failed to generate notes"}, status=500)

        # Save to DB
        note_obj = Note.objects.create(userId=userId, topic=topic, notes=notes)

        # Return the generated notes to the frontend
        notes_data = {
            "userId": userId,
            "topic": topic,
            "notes": notes,
            "created_at": note_obj.created_at
        }

        return JsonResponse({
            "data": notes_data,
            "message": "Notes generated and saved successfully"
        }, status=200)

    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return JsonResponse({"error": f"Unexpected server error: {str(e)}"}, status=500)

@require_GET
@csrf_exempt
def get_notes_for_user(request):
    """Fetch all notes for a user by userId (GET param)"""
    userId = request.GET.get("userId")
    if not userId:
        return JsonResponse({"error": "userId query parameter is required"}, status=400)
    notes = Note.objects.filter(userId=userId).order_by("-created_at")
    notes_list = [
        {
            "id": n.id,
            "userId": n.userId,
            "topic": n.topic,
            "notes": n.notes,
            "created_at": n.created_at
        }
        for n in notes
    ]
    return JsonResponse({"notes": notes_list, "message": "Notes fetched successfully"}, status=200)

@require_http_methods(["PATCH"])
@csrf_exempt
def update_note(request, note_id):
    """Update a note's topic or notes by id (PATCH)"""
    try:
        note = Note.objects.get(id=note_id)
    except Note.DoesNotExist:
        return JsonResponse({"error": "Note not found"}, status=404)
    try:
        data = json.loads(request.body.decode("utf-8"))
    except Exception as e:
        return JsonResponse({"error": f"Invalid JSON: {str(e)}"}, status=400)
    topic = data.get("topic")
    notes = data.get("notes")
    if topic:
        note.topic = topic
    if notes:
        note.notes = notes
    note.save()
    return JsonResponse({
        "id": note.id,
        "userId": note.userId,
        "topic": note.topic,
        "notes": note.notes,
        "created_at": note.created_at,
        "message": "Note updated successfully"
    }, status=200)

@require_http_methods(["DELETE"])
@csrf_exempt
def delete_note(request, note_id):
    """Delete a note by id (DELETE)"""
    try:
        note = Note.objects.get(id=note_id)
    except Note.DoesNotExist:
        return JsonResponse({"error": "Note not found"}, status=404)
    note.delete()
    return JsonResponse({"message": "Note deleted successfully"}, status=200)
